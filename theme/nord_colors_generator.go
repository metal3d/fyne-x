//go:build ignore
// +build ignore

/*
This tool will visit the Adwaita color page and generate a Go file with all the colors.
To add a new color, just add it to the colorToGet map. The key is the name of the color for Fyne, and the color name
is the name of the color in the Adwaita page without the "@".
*/

package main

import (
	"bytes"
	"fmt"
	"go/format"
	"image/color"
	"io/ioutil"
	"log"
	"net/http"
	"os"
	"regexp"
	"text/template"
)

const (
	nordColorPage = "https://www.nordtheme.com/docs/colors-and-palettes"
	output        = "nord_colors.go"
	sourceTpl     = `package theme

// This file is generated by nord_colors_generator.go
// Please do not edit manually, use:
// go generate ./theme/...
//
// The colors are taken from: {{.ColorPage}}

import (
	"image/color"

	"fyne.io/fyne/v2"
	"fyne.io/fyne/v2/theme"
)

var nordDarkScheme = map[fyne.ThemeColorName]color.Color{
{{- range $key, $value := .DarkScheme }}
    {{$key}}: {{ printf "color.RGBA{0x%02x, 0x%02x, 0x%02x, 0x%02x}" $value.Col.R $value.Col.G $value.Col.B $value.Col.A }}, // Nord color name @{{$value.NordName}}
{{- end }}
}

var nordLightScheme = map[fyne.ThemeColorName]color.Color{
{{- range $key, $value := .LightScheme }}
    {{$key}}: {{ printf "color.RGBA{0x%02x, 0x%02x, 0x%02x, 0x%02x}" $value.Col.R $value.Col.G $value.Col.B $value.Col.A }}, // Nord color name @{{$value.NordName}}
{{- end }}
}`
)

var (
	divColorMatcher = regexp.MustCompile(`<div color="(#.*?)"`)
	nordScheme      = map[string]*color.RGBA{
		// force for shadow
		"dark0": {0x00, 0x00, 0x00, 0x5b},
		"dark1": {0x00, 0x04, 0x00, 0x11},
	}
	darkPalette = map[string]string{
		"theme.ColorNameBackground":        "nord0",
		"theme.ColorNameForeground":        "nord6", // recommended for text
		"theme.ColorNameMenuBackground":    "nord1",
		"theme.ColorNameSelection":         "nord3",
		"theme.ColorNameOverlayBackground": "nord1",
		"theme.ColorNamePrimary":           "nord8", // or nord 10
		"theme.ColorNameInputBackground":   "nord1",
		"theme.ColorNameButton":            "nord1",
		"theme.ColorNameShadow":            "dark0",
		"theme.ColorNameSuccess":           "nord14",
		"theme.ColorNameWarning":           "nord12",
		"theme.ColorNameError":             "nord11",
		"theme.ColorRed":                   "nord11",
		"theme.ColorOrange":                "nord12",
		"theme.ColorYellow":                "nord13",
		"theme.ColorGreen":                 "nord14",
		"theme.ColorBlue":                  "nord9", // or nord10
		"theme.ColorPurple":                "nord15",
		"theme.ColorBrown":                 "nord3", // no brown in nord
		"theme.ColorGray":                  "nord4",
	}
	lightPalette = map[string]string{
		"theme.ColorNameBackground":        "nord6",
		"theme.ColorNameForeground":        "nord0", // recommended for text
		"theme.ColorNameMenuBackground":    "nord5",
		"theme.ColorNameSelection":         "nord7",
		"theme.ColorNameOverlayBackground": "nord5",
		"theme.ColorNamePrimary":           "nord7", // or nord 10
		"theme.ColorNameInputBackground":   "nord5",
		"theme.ColorNameButton":            "nord4",
		"theme.ColorNameShadow":            "dark1",
		"theme.ColorNameSuccess":           "nord14",
		"theme.ColorNameWarning":           "nord12",
		"theme.ColorNameError":             "nord11",
		"theme.ColorRed":                   "nord11",
		"theme.ColorOrange":                "nord12",
		"theme.ColorYellow":                "nord13",
		"theme.ColorGreen":                 "nord14",
		"theme.ColorBlue":                  "nord9", // or nord10
		"theme.ColorPurple":                "nord15",
		"theme.ColorBrown":                 "nord3", // no brown in nord
		"theme.ColorGray":                  "nord4",
	}
)

type colorInfo struct {
	Col      *color.RGBA // go formated color (color.RGBA{0x00, 0x00, 0x00, 0x00})
	NordName string      // nord color name
}

func main() {

	darkScheme := map[string]colorInfo{}
	lightScheme := map[string]colorInfo{}

	reps, err := http.Get(nordColorPage)
	if err != nil {
		log.Fatal(err)
	}
	defer reps.Body.Close()
	htpage, err := ioutil.ReadAll(reps.Body)
	if err != nil {
		log.Fatal(err)
	}

	divColors := divColorMatcher.FindAllStringSubmatch(string(htpage), -1)
	for i, divColor := range divColors {
		nordName := fmt.Sprintf("nord%d", i)
		nordScheme[nordName], err = stringToColor(divColor[1])
		if err != nil {
			log.Fatal(err)
		}
	}

	for key, value := range lightPalette {
		lightScheme[key] = colorInfo{
			Col:      nordScheme[value],
			NordName: value,
		}
	}
	for key, value := range darkPalette {
		darkScheme[key] = colorInfo{
			Col:      nordScheme[value],
			NordName: value,
		}
	}

	out, err := os.Create(output)

	if err != nil {
		log.Fatal(err)
	}
	defer out.Close()

	tpl := template.New("source")
	tpl, err = tpl.Parse(sourceTpl)
	if err != nil {
		log.Fatal(err)
	}
	// generate the source
	buffer := bytes.NewBuffer(nil)
	err = tpl.Execute(buffer, struct {
		LightScheme map[string]colorInfo
		DarkScheme  map[string]colorInfo
		ColorPage   string
	}{
		LightScheme: lightScheme,
		DarkScheme:  darkScheme,
		ColorPage:   nordColorPage,
	})
	if err != nil {
		log.Fatal(err)
	}

	// format the file
	if formatted, err := format.Source(buffer.Bytes()); err != nil {
		log.Fatal(err)
	} else {
		out.Write(formatted)
	}

}

func stringToColor(s string) (c *color.RGBA, err error) {
	if c == nil {
		c = &color.RGBA{}
	}
	c.A = 0xff
	switch len(s) {
	case 7:
		_, err = fmt.Sscanf(s, "#%02x%02x%02x", &c.R, &c.G, &c.B)
	case 9:
		_, err = fmt.Sscanf(s, "#%02x%02x%02x%02x", &c.R, &c.G, &c.B, &c.A)
	default:
		// rgba(...) format
		var a float32
		_, err = fmt.Sscanf(s, "rgba(%d, %d, %d, %f)", &c.R, &c.G, &c.B, &a)
		c.A = uint8(a * 255)
	}
	return
}
